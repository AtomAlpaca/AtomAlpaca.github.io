<!DOCTYPE html>
<html lang = "zh_cn">

<head>
	<meta charset = "utf-8"/>
		<meta name = "author" content = "AtomAlpaca">
		<title>「题解」 P4261 白金元首与克劳德斯</title>
	<link rel = "stylesheet" href = "./style.css" type = "text/css"/>
	<link rel="stylesheet"
      href="https://unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/panda-syntax-dark.min.css">
	<script src="https://unpkg.com/@highlightjs/cdn-assets@11.6.0/highlight.min.js"></script>

</head>

<body>
	<header>
				<p>
			<h1>
				「题解」 P4261 白金元首与克劳德斯
			</h1>
		</p>
		<p style = "text-align: center">
						AtomAlpaca
								</p>
				
			</header>
	<script>hljs.highlightAll();</script>
		<h2>
		Table of contents
	</h2>
	<ul>
<li><a href="#题目" id="toc-题目">题目</a></li>
<li><a href="#正文" id="toc-正文">正文</a></li>
<li><a href="#代码" id="toc-代码">代码</a></li>
</ul>
	
	<h2 id="题目">题目</h2>
<p><span>link</span></p>
<h2 id="正文">正文</h2>
<p>首先证明, 任意时刻不可能有一个点被三个及以上个云朵覆盖.</p>
<p>考虑反证法, 假设有一点会被三个覆盖,
则必有至少两个云朵有重合部分且运动方向相同.
因为所有云朵都运动速度都相等, 这两个云朵在任意时刻都重合, 而这和题目中的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
时刻没有重合的云朵矛盾.</p>
<p>因此答案只可能是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
或
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>.
我们只需要考虑是否有某一时刻存在两朵重合都云朵即可.</p>
<p>考虑到运动方向相同的云朵不可能重合,
我们只需要选取某一方向的云朵和另一方向的云朵逐个比较即可, 最坏复杂度是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math>.</p>
<p>考虑如何判断. 由于只需要判断是否重合, 这两个云朵的具体坐标并不重要,
我们要考虑的是云朵的相对位置. 两个云朵都运动的情况难以处理,
因此我们给每一个云朵都加上一个方向为 x 轴负方向的速度,
这样对两者的相对位置不会产生影响, 但我们横向的云朵转化为了静止的状态,
而竖直方向都运动变为了向左上方斜
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>45</mn><annotation encoding="application/x-tex">45</annotation></semantics></math>
度的运动.</p>
<p>因为时间是任意的, 任意运动云朵
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
覆盖过的位置就是其左下角和右上角的轨迹围成的平行四边形.
这两点的坐标分别为
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>,</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x_i, y_i)</annotation></semantics></math>
和
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><msub><mi>w</mi><mi>i</mi></msub><mo>,</mo><msub><mi>y</mi><mi>i</mi></msub><mo>+</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x_i + w_i, y_i + h_i)</annotation></semantics></math>,
因此这两个轨迹的方程分别为
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo>=</mo><mi>−</mi><mi>x</mi><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>+</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">y_1 = -x + (y_i + x_i)</annotation></semantics></math>
和
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>=</mo><mi>−</mi><mi>x</mi><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>+</mo><msub><mi>h</mi><mi>i</mi></msub><mo>+</mo><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">y_2 = -x + (y_i + h_i + x_i + w_i)</annotation></semantics></math>.</p>
<p>如果
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mn>1</mn></msub><annotation encoding="application/x-tex">y_1</annotation></semantics></math>
在静止云朵
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
的右上角上方穿过, 或者
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mn>2</mn></msub><annotation encoding="application/x-tex">y_2</annotation></semantics></math>
在其左下角的下方穿过, 那么这两个云朵不能够重合. 也即</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>−</mi><msub><mi>x</mi><mi>j</mi></msub><mo>−</mo><msub><mi>w</mi><mi>j</mi></msub><mo>+</mo><msub><mi>y</mi><mi>i</mi></msub><mo>+</mo><msub><mi>x</mi><mi>i</mi></msub><mo>≥</mo><msub><mi>y</mi><mi>j</mi></msub><mo>+</mo><msub><mi>h</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">-x_j - w_j + y_i + x_i \ge  y_j + h_j</annotation></semantics></math></p>
<p>或</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>−</mi><msub><mi>x</mi><mi>j</mi></msub><mo>+</mo><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><msub><mi>w</mi><mi>i</mi></msub><mo>+</mo><msub><mi>y</mi><mi>i</mi></msub><mo>+</mo><msub><mi>h</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">-x_j + x_i + w_i + y_i + h_i \le  y_j</annotation></semantics></math>
时不能重合.</p>
<p>整理可得,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
和
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
能够重合都充要条件为:</p>
<div class="aligned">
<p>x_i + y_i &amp;&lt; x_j + w_j + y_j + h_j<br />
x_j + y_j &amp;&lt; x_i + w_i + y_i + h_i</p>
</div>
<p>逐个判断即可. 但这样交上去会 TLE 一个点, 考虑优化.</p>
<p>将所有静止节点按照
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub><mo>+</mo><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_j +y_j</annotation></semantics></math>
从小到大排序, 假如一个移动节点枚举到某一静止节点时满足
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub><mo>+</mo><msub><mi>y</mi><mi>j</mi></msub><mo>≥</mo><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><msub><mi>w</mi><mi>i</mi></msub><mo>+</mo><msub><mi>y</mi><mi>i</mi></msub><mo>+</mo><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_j + y_j \ge x_i + w_i + y_i + h_i</annotation></semantics></math>,
则不需要继续向下枚举, 放弃这个移动节点即可.</p>
<h2 id="代码">代码</h2>
<pre data-tabsize="4"><code>#include &lt;bits/stdc++.h&gt;

using std::cin;
using std::cout;
using std::vector;

int T, n, x, y, w, h, d;

struct Node
{
    int a, b;
};

vector &lt;Node&gt; a, b;

bool cmp(Node n1, Node n2)
{
    return n1.a &lt; n2.a;
}

void clear()
{
    a.clear(); b.clear();
}

void solve()
{
    clear();
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; ++i)
    {
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w &gt;&gt; h &gt;&gt; d;
        if (d) { a.push_back(Node{x + y, x + y + w + h}); }
        else   { b.push_back(Node{x + y, x + y + w + h}); }
    }

    std::sort(b.begin(), b.end(), cmp);

    for (Node i : a)
    {
        for (Node j : b)
        {
            if (i.a &lt; j.b and j.a &lt; i.b) { cout &lt;&lt; &quot;2\n&quot;; return; }
            if (i.b &lt;= j.a)              { break; }
        }
    }
    cout &lt;&lt; 1 &lt;&lt; &#39;\n&#39;;
}

int main()
{
    cin.tie(NULL);
    cout.tie(NULL);
    std::ios::sync_with_stdio(false);
    cin &gt;&gt; T;
    while (T--) { solve(); }
} </code></pre>
</body>
