<!DOCTYPE html>
<html lang = "zh_cn">

<head>
	<meta charset = "utf-8"/>
		<meta name = "author" content = "AtomAlpaca">
		<title>「题解」CF868F Yet Another Minimization Problem</title>
	<link rel = "stylesheet" href = "./style.css" type = "text/css"/>
	<link rel="stylesheet"
      href="https://unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/panda-syntax-dark.min.css">
	<script src="https://unpkg.com/@highlightjs/cdn-assets@11.6.0/highlight.min.js"></script>

</head>

<body>
	<header>
				<p>
			<h1>
				「题解」CF868F Yet Another Minimization Problem
			</h1>
		</p>
		<p style = "text-align: center">
						AtomAlpaca
								</p>
				
			</header>
	<script>hljs.highlightAll();</script>
		<h2>
		Table of contents
	</h2>
	<ul>
<li><a href="#题意" id="toc-题意">题意</a></li>
<li><a href="#题解" id="toc-题解">题解</a></li>
</ul>
	
	<h2 id="题意">题意</h2>
<p>给定一个序列
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>，要把它分成恰好
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
个子段。每个代价的费用是其中相同元素的对数。求所有子段的代价之和的最小值。</p>
<p><a
href="https://codeforces.com/problemset/problem/868/F">link</a></p>
<h2 id="题解">题解</h2>
<p>首先有一个暴力的 dp:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><munderover><mo>min</mo><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><mi>i</mi></munderover><mrow><msub><mi>f</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">f_{i, j} = \min_{k = 2}^{i}{f_{k - 1, j - 1} + v(k, i)}</annotation></semantics></math></p>
<p>其中
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mo>,</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">v(l, r)</annotation></semantics></math>
是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mi>l</mi><mo>,</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math>
这一子段的代价。</p>
<p>这个形式让人不禁四边形不等式了起来。我们考虑证明
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>
满足四边形不等式。</p>
<p>我们不妨设
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mo>,</mo><mi>r</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">w(l, r, s, t)</annotation></semantics></math>
是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mi>l</mi><mo>,</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math>
中的元素和
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[s, t]</annotation></semantics></math>
中元素相等的对数。那么对于
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi><mo>≤</mo><mi>c</mi><mo>≤</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">a \le b \le c \le d</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mn>2</mn><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>w</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>w</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>−</mi></mtd><mtd columnalign="left" style="text-align: left"><mn>2</mn><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>w</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>w</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>w</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>−</mi><mi>w</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>≤</mo></mtd><mtd columnalign="left" style="text-align: left"><mn>0</mn></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
        &amp; v(a, c) + v(b, d) - (v(a, d) + v(b, d))\\
        =&amp; 2v(b, c) + v(a, b) + v(c, d) + w(a, b, b, c) + w(b, c, c, d) \\
        -&amp; 2v(b, c) - v(a, b) - v(c, d) - w(a, b, b, c) - w(b, c, c, d) - w(a, b, c, d) \\
        =&amp; -w(a, b, c, d) \\
        \le&amp; 0
    \end{aligned}</annotation></semantics></math></p>
<p>因此得到
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>
满足四边形不等式。于是我们可以利用决策单调性来做这个问题。</p>
<p>现在问题在于我们很难
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math>
地求解
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>。那么我们考虑用类似莫队的思路，维护一个桶每次移动两个端点。然后我们发现对于每个分治区间，我们指针移动的次数是区间长度的一半，而分治的深度一共是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>log</mo><annotation encoding="application/x-tex">\log</annotation></semantics></math>
层，因此算下来我们的指针只会移动
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>k</mi><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(nk \log n)</annotation></semantics></math>
次。</p>
<p>至此我们可以在
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>k</mi><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(nk \log n)</annotation></semantics></math>
的时间复杂度解决这个问题。可以把 dp
的第二维用滚动数组优化掉，不过这题并不卡空间。</p>
<pre><code>#include &lt;bits/stdc++.h&gt;

typedef long long ll;
const int MAX = 1e5 + 5;
const ll INF = 1e16;
int n, k, L = 1, R = 0; ll res;
ll f[MAX][2]; int a[MAX], b[MAX];

ll w(int l, int r)
{
    while (R &lt; r) { ++R; res += b[a[R]]++; }
    while (L &gt; l) { --L; res += b[a[L]]++; }
    while (R &gt; r) { res -= --b[a[R]]; --R; }
    while (L &lt; l) { res -= --b[a[L]]; ++L; }
    return res;
}

void solve(int l, int r, int s, int t, int x)
{
    if (l &gt; r) { return ; }
    int k = l + ((r - l) &gt;&gt; 1), p = s; ll mn = INF;
    for (int i = s; i &lt;= std::min(k, t); ++i)
    {
        if (f[i - 1][x ^ 1] + w(i, k) &lt; mn) { p = i; mn = f[i - 1][x ^ 1] + w(i, k); }
    }
    f[k][x] = mn;
    solve(l, k - 1, s, p, x); solve(k + 1, r, p, t, x);
}

int main()
{
    memset(f, 0x7f, sizeof(f)); f[0][0] = 0;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
    for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;a[i]); }
    for (int i = 1; i &lt;= k; ++i) { solve(1, n, 1, n, i &amp; 1); }
    printf(&quot;%lld&quot;, f[n][k &amp; 1]);
}</code></pre>
</body>
