<!DOCTYPE html>
<html lang = "zh_cn">

<head>
	<meta charset = "utf-8"/>
		<meta name = "author" content = "AtomAlpaca">
		<title>「题解」CF1764G3 Doremy’s Perfect DS Class</title>
	<link rel = "stylesheet" href = "./style.css" type = "text/css"/>
	<link rel="stylesheet"
      href="https://unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/panda-syntax-dark.min.css">
	<script src="https://unpkg.com/@highlightjs/cdn-assets@11.6.0/highlight.min.js"></script>

</head>

<body>
	<header>
				<p>
			<h1>
				「题解」CF1764G3 Doremy’s Perfect DS Class
			</h1>
		</p>
		<p style = "text-align: center">
						AtomAlpaca
								</p>
				
			</header>
	<script>hljs.highlightAll();</script>
		<h2>
		Table of contents
	</h2>
	<ul>
<li><a href="#题目" id="toc-题目">题目</a></li>
<li><a href="#题解" id="toc-题解">题解</a>
<ul>
<li><a href="#easy-version" id="toc-easy-version">easy version</a></li>
<li><a href="#medium-version" id="toc-medium-version">medium
version</a></li>
<li><a href="#hard-version" id="toc-hard-version">hard version</a></li>
</ul></li>
<li><a href="#ux4ee3ux7801" id="toc-ux4ee3ux7801">代码</a></li>
</ul>
	
	<h2 id="题目">题目</h2>
<p>交互题。每次产生一个
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[1,n]</annotation></semantics></math>
的排列
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>。</p>
<p>每次询问
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>,</mo><mi>r</mi><mo>,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">l,r,k</annotation></semantics></math>，得到
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">⌊</mo><mfrac displaystyle="true"><msub><mi>p</mi><mi>l</mi></msub><mi>k</mi></mfrac><mo stretchy="true" form="postfix">⌋</mo></mrow><mo>,</mo><mrow><mo stretchy="true" form="prefix">⌊</mo><mfrac displaystyle="true"><msub><mi>p</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>k</mi></mfrac><mo stretchy="true" form="postfix">⌋</mo></mrow><mo>,</mo><mi>⋯</mi><mo>,</mo><mrow><mo stretchy="true" form="prefix">⌊</mo><mfrac displaystyle="true"><msub><mi>p</mi><mi>r</mi></msub><mi>k</mi></mfrac><mo stretchy="true" form="postfix">⌋</mo></mrow></mrow><annotation encoding="application/x-tex">\left\lfloor\dfrac{p_l}k\right\rfloor,\left\lfloor\dfrac{p_{l+1}}k\right\rfloor,\cdots,\left\lfloor\dfrac{p_r}k\right\rfloor</annotation></semantics></math>
中数的种类数。</p>
<p>要求在
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>30</mn><annotation encoding="application/x-tex">30</annotation></semantics></math>(easy)/<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>24</mn><annotation encoding="application/x-tex">24</annotation></semantics></math>(medium)/<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>20</mn><annotation encoding="application/x-tex">20</annotation></semantics></math>(hard)
次询问内找到
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
的位置。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1024</mn></mrow><annotation encoding="application/x-tex">n \le 1024</annotation></semantics></math>。</p>
<p>很厉害的一道题目！然而自己只想到 medium 的做法。但是很喜欢！</p>
<h2 id="题解">题解</h2>
<h3 id="easy-version">easy version</h3>
<p>看到
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1024</mn><annotation encoding="application/x-tex">1024</annotation></semantics></math>
和
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>30</mn><annotation encoding="application/x-tex">30</annotation></semantics></math>，感觉像是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">3\log n</annotation></semantics></math>。于是猜是二分。</p>
<p>然后发现
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k=2</annotation></semantics></math>
的情况相当于把每个
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>x</mi><mo>,</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2x, 2x+1</annotation></semantics></math>
配对，最后剩下无法配对的是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
和
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
为偶数时）。考虑把
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
是奇数和偶数的情况分开解决。</p>
<p>当
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
为奇数时，我们考虑先把
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
删去，于是把这个序列分成两个区间时，两个区间内的、无法配对的数的数量是相等的。然后我们把
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
扔到某一边，这边的无法配对的数的数量会增加，我们就能判定
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
在哪一边了。</p>
<p>考虑怎么求无法配对的数的数量。设一次询问
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>,</mo><mi>r</mi><mo>,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">l, r, k</annotation></semantics></math>
的答案为
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mo>,</mo><mi>r</mi><mo>,</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">q(l, r, k)</annotation></semantics></math>，那么
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mo>,</mo><mi>r</mi><mo>,</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(r - l + 1) - q(l, r, k)</annotation></semantics></math>
显然就是配对的对数，因此未配对的对数就是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mn>2</mn><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mo>,</mo><mi>r</mi><mo>,</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(r - l + 1) - 2\times ((r - l + 1) - q(l, r, k))</annotation></semantics></math>，也就是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mo>,</mo><mi>r</mi><mo>,</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">2 q(l, r, k) - (r - l + 1)</annotation></semantics></math>。</p>
<p>于是我们可以通过两次操作把目标范围缩小一半，并且操作次数是十分优秀的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(2 \log n)</annotation></semantics></math>。</p>
<p>然后考虑
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
为偶数怎么做。发现只是在奇数的情况下多了一个
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
的干扰。然后我们发现一个区间
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mi>l</mi><mo>,</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math>
含有
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
当且仅当
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mo>,</mo><mi>r</mi><mo>,</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">q(l, r, k)=2</annotation></semantics></math>，于是我们可以提前把
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
的位置二分出来，然后套用奇数的方法，加下特判就好了。操作次数是并不十分优秀的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>3</mn><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(3 \log n)</annotation></semantics></math>。但是能够通过
easy version。</p>
<h3 id="medium-version">medium version</h3>
<p>考虑优化 easy version 的做法。</p>
<p>我们发现每次把排列划分成两段时，如果
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1, n</annotation></semantics></math>
在同侧，我们其实是不用处理的，直接往未配对较多的一边跳就行；在异侧时，我们得到的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
的新范围内一定不会再有
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>。于是我们发现异侧的情况最多仅有一次，而且我们只需要知道
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
在哪一边即可。于是我们可以把操作次数优化到
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo>log</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(2 \log n + 1)</annotation></semantics></math>。足以通过
medium version。</p>
<h3 id="hard-version">hard version</h3>
<p>我们发现
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo>log</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(2 \log n + 1)</annotation></semantics></math>
最大只有
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>21</mn><annotation encoding="application/x-tex">21</annotation></semantics></math>，恰好无法通过
hard version。考虑继续优化。</p>
<p>考虑偶数情况一定会经过
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r = l + 1</annotation></semantics></math>
的区间，这个区间是较好处理的。分为两种情况。</p>
<ol>
<li><p>还未出现
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1, n</annotation></semantics></math>
异侧，即
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l, r</annotation></semantics></math>
对应的分别是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1, n</annotation></semantics></math>；</p></li>
<li><p>出现了
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1, n</annotation></semantics></math>
异侧，即
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l, r</annotation></semantics></math>
其中一个是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>，另一个不一定。</p></li>
</ol>
<p>第一种情况是好处理的，通过询问
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mi>l</mi><mo>,</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">q(1, l, n)</annotation></semantics></math>
或
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo>,</mo><mi>n</mi><mo>,</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">q(r, n, n)</annotation></semantics></math>
判断其中一个是否为
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
即可。第二种情况则稍难一些。</p>
<p>由于我们现在的区间为
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mi>l</mi><mo>,</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math>，则我们之前一定询问过
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mi>r</mi><mo>,</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mo>,</mo><mi>n</mi><mo>,</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo>,</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">q(1, l - 1, 2), q(1, r, 2), q(l, n, n), q(r + 1, n, n)</annotation></semantics></math>
这些区间。我们可以利用这些信息。</p>
<ul>
<li><p>假如
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mi>r</mi><mo>,</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">q(1, r, 2) = q(1, l - 1, 2) + 1</annotation></semantics></math>
说明加上
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l, r</annotation></semantics></math>
之后，和
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>,</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[1, l-1]</annotation></semantics></math>
中的区间匹配上了一个数，于是判断
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mi>l</mi><mo>,</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">q(1, l, 2)</annotation></semantics></math>
是否等于
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">q(1, l - 1, 2)</annotation></semantics></math>
便能得到
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>l</mi><annotation encoding="application/x-tex">l</annotation></semantics></math>
这个位置是和前面匹配上的数还是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>；</p></li>
<li><p>否则，一定有
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mo>,</mo><mi>n</mi><mo>,</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo>,</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">q(l, n, n) = q(r + 1, n, n) + 1</annotation></semantics></math>，这种情况的处理方式和上面是对称的。</p></li>
</ul>
<p>于是我们在
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r = l + 1</annotation></semantics></math>
的区间上优化掉了一次操作，操作次数变为
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(2 \log n)</annotation></semantics></math>，可以通过
hard version。</p>
<h2 id="ux4ee3ux7801">代码</h2>
<pre><code>#include &lt;bits/stdc++.h&gt;

bool flg, lft;
int n;
std::map &lt; std::pair&lt;int, int&gt;, int &gt; mp;

int qry(int l, int r, int k)
{
  if (l == r) { return 1; }
  if (l &gt; r) { return 0; }
  if (k == 2 and mp.find({l, r}) != mp.end()) { return mp[{l, r}]; }
  int res = 0;
  printf(&quot;? %d %d %d\n&quot;, l, r, k); fflush(stdout);
  scanf(&quot;%d&quot;, &amp;res);
  if (k == 2) { mp[{l, r}] = res; }
  return res;
}

int solve1(int l, int r)
{
  if (l == r) { return l; }
  int k = l + ((r - l) &gt;&gt; 1), x = 2 * qry(1, k, 2) - k, y = 2 * qry(k + 1, n, 2) - (n - k);
  if (x &gt; y) { return solve1(l, k); } else { return solve1(k + 1, r); }
}

int solve0(int l, int r)
{
  if (l == r) { return l; }
  if (r - l == 1)
  {
    if (!flg)
    { 
      if (l &gt; 1) { return ((qry(1, l, n) == 2) ? r : l); }
      else { return qry(r, n, n) == 2 ? l : r; };
    }
    if (qry(1, r, 2) == qry(1, l - 1, 2) + 1)
    {
      if (qry(1, l, 2) == qry(1, l - 1, 2)) { return r; } else { return l; }
    }
    else
    {
      if (qry(r, n, 2) == qry(r + 1, n, 2)) { return l; } else { return r; }
    }
  }
  int k = l + ((r - l) &gt;&gt; 1); int x = 2 * qry(1, k, 2) - k, y = 2 * qry(k + 1, n, 2) - (n - k);
  if (x == y)
  {
    if (!flg)
    {
      if (qry(1, k, n) == 2) { flg = lft = true; } else { flg = true; }
    }
    if (lft) { solve0(k + 1, r); } else { return solve0(l, k); }
  }
  if (x &gt; y) { return solve0(l, k); } else { return solve0(k + 1, r); }
}

int main()
{
  scanf(&quot;%d&quot;, &amp;n);
  if (n &amp; 1) { printf(&quot;! %d\n&quot;, solve1(1, n)); } else { printf(&quot;! %d\n&quot;, solve0(1, n)); }
}</code></pre>
</body>
