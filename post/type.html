<!DOCTYPE html>
<html lang = "zh_cn">

<head>
	<meta charset = "utf-8"/>
		<meta name = "author" content = "AtomAlpaca">
		<title>类型论学习笔记</title>
	<link rel = "stylesheet" href = "./style.css" type = "text/css"/>
	<link rel="stylesheet"
      href="https://unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/panda-syntax-dark.min.css">
	<script src="https://unpkg.com/@highlightjs/cdn-assets@11.6.0/highlight.min.js"></script>

</head>

<body>
	<header>
				<p>
			<h1>
				类型论学习笔记
			</h1>
		</p>
		<p style = "text-align: center">
						AtomAlpaca
								</p>
				
			</header>
	<script>hljs.highlightAll();</script>
		<h2>
		Table of contents
	</h2>
	<ul>
<li><a href="#前言" id="toc-前言">前言</a></li>
<li><a href="#前置知识" id="toc-前置知识">前置知识</a>
<ul>
<li><a href="#元语言和形式语言"
id="toc-元语言和形式语言">元语言和形式语言</a></li>
<li><a href="#相继演算" id="toc-相继演算">相继演算</a></li>
<li><a href="#柯里化" id="toc-柯里化">柯里化</a></li>
</ul></li>
<li><a href="#简单类型" id="toc-简单类型">简单类型</a>
<ul>
<li><a href="#无类型-lambda-演算" id="toc-无类型-lambda-演算">无类型
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算</a>
<ul>
<li><a href="#alpha-转换"
id="toc-alpha-转换"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-转换</a></li>
<li><a href="#规约和暨约形式"
id="toc-规约和暨约形式">规约和暨约形式</a></li>
<li><a href="#邱奇编码" id="toc-邱奇编码">邱奇编码</a></li>
</ul></li>
<li><a href="#简单类型-lambda-演算"
id="toc-简单类型-lambda-演算">简单类型
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算</a>
<ul>
<li><a href="#类型论和一个类型论"
id="toc-类型论和一个类型论">类型论和一个类型论</a></li>
</ul></li>
</ul></li>
</ul>
	
	<h1 id="前言">前言</h1>
<p>是个人学习笔记，会有很多自己的理解和想法，可能有不准确甚至错误的地方。如有发现可以来嘲讽笔者！</p>
<p>由于类型论相关的术语翻译混乱或者难以翻译，有些术语会附上英文原文或直接使用英文。</p>
<p>尝试把笔记写成一篇浅显易懂的入门读物，因此可能很多在诸位认为不重要的地方会花很多笔墨详细解释，以帮助新人理解。</p>
<h1 id="前置知识">前置知识</h1>
<h2 id="元语言和形式语言">元语言和形式语言</h2>
<p>……</p>
<h2 id="相继演算">相继演算</h2>
<p>……</p>
<h2 id="柯里化">柯里化</h2>
<p>……？</p>
<h1 id="简单类型">简单类型</h1>
<h2 id="无类型-lambda-演算">无类型
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算</h2>
<p>为什么会产生类型？</p>
<p>为了回答这个问题，我们现看看没有类型会发生什么。接下来我们会介绍无类型的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算。说它没有类型也不准确，我们也可以看作它所有的东西共用一个类型。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算中一个项（term）定义为
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mo>:=</mo><mi>x</mi><mrow><mo stretchy="true" form="prefix">|</mo><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">|</mo></mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">term := x | t_1t_2 | \lambda x.t</annotation></semantics></math>，这是说一个项要么是一个单独的变量
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>，要么是两个项的拼接
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_1 t_2</annotation></semantics></math>，要么是形如
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\lambda x.t</annotation></semantics></math>
的形式。</p>
<p>拼接两个项被称为应用（application），它是左结合的，也就是说
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mspace width="0.222em"></mspace><msub><mi>t</mi><mn>2</mn></msub><mspace width="0.222em"></mspace><msub><mi>t</mi><mn>3</mn></msub><mi>⋯</mi><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_1\ t_2\ t_3\cdots t_n</annotation></semantics></math>
代表
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>⋯</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mn>1</mn></msub><mspace width="0.222em"></mspace><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>t</mi><mn>3</mn></msub><mi>⋯</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">(\cdots (t_1\ t_2)t_3 \cdots )t_n</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\lambda x.t</annotation></semantics></math>
这种形式被称为抽象（abstrcation）,其中
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
是一个变量，<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
是一个项。抽象和我们中学时期理解的函数很像，比如我们定义一个函数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">f(x) = x^2</annotation></semantics></math>，我们传入一个参数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>
得到的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">f(y) = y^2</annotation></semantics></math>
其实就是把
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math>
中的所有
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
换成了
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>；而
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">(\lambda x.t) y</annotation></semantics></math>，也就是把
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>
应用到这个项上，代表把项
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
中所有
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
都替换成
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>。注意我们一般规定抽象的优先级比应用要高，也就是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\lambda x.t_1t_2</annotation></semantics></math>
说的是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda x.(t_1t_2)</annotation></semantics></math>
而不是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">(\lambda x.t_1)t_2</annotation></semantics></math>。</p>
<p>我们把
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
中的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
全部替换成
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>
的结果写成
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>x</mi><mo>↦</mo><mi>y</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">M[x \mapsto y]</annotation></semantics></math>。</p>
<h3
id="alpha-转换"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-转换</h3>
<p>我们刚刚知道了
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算的基本规则，那么请思考一个问题：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>y</mi><mi>.</mi><mi>λ</mi><mi>x</mi><mi>.</mi><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>x</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">(\lambda y.\lambda x.y)xz</annotation></semantics></math>
该怎么算？最后得到的是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
还是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>？换言之我们第一步应用得到的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">(\lambda x.x)z</annotation></semantics></math>
中的两个
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
是不是同一个
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>？</p>
<p>其实如果我们换一个变量名
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>y</mi><mi>.</mi><mi>λ</mi><mi>t</mi><mi>.</mi><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>x</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">(\lambda y.\lambda t.y)xz</annotation></semantics></math>
就很清晰了。这个项毫无疑问等于
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>，而我们直觉上认为，<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>t</mi><mi>.</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">\lambda t.y</annotation></semantics></math>
和
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">\lambda x.y</annotation></semantics></math>
是等价的东西，就像
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>sin</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">f(x) = \sin x</annotation></semantics></math>
和
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>sin</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f(y) = \sin y</annotation></semantics></math>
没什么区别一样。事实上在
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算中也是这样规定的。我们接下来形式化地描述一下这种”重命名“的过程。</p>
<p>在一个项
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
中，只要不是在
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\lambda x.</annotation></semantics></math>
的位置使用了一个变量
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>，我们就称这个变量
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
在项
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
中出现（occurence）了。对于一个项
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">\lambda x.M</annotation></semantics></math>，如果
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
这个项中出现了
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>，那么这个项中的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
就是一个绑定变量（bounded variable），否则是一个自由变量（bounded
variable）。我们之前说的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>x</mi><mo>↦</mo><mi>y</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">t[x \mapsto y]</annotation></semantics></math>
严格定义是将
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
中所有自由的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
换成
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>。</p>
<p>同时，我们认为将
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">\lambda x.M</annotation></semantics></math>
中的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
和
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
共同换成一个
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
中自由的变量，变换后的项和原来是等价的。这就是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-转换（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-conversion）。显然地，我们可以把一个项的所有变量都转化为两两不同的变量，这样就不会出现我们上面草歧义。</p>
<p>而之所以我们出现了上面的歧义，是因为我们采用了字符串来代指数学对象，因此我们即使用着同样的名字
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>，两个
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
想表达的意思却是不一样的，就会造成一些混淆。</p>
<h3 id="规约和暨约形式">规约和暨约形式</h3>
<p>归约 (reduction) 主要描述了一个项怎么化简,
或者说计算。而暨约形式（normal
form）则是经过化简得到的所谓“最简形式”。在基础的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算中主要有两条规则：</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow></mrow><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>M</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>y</mi><mo>≡</mo><mi>M</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>x</mi><mo>↦</mo><mi>y</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow></mfrac><mi>β</mi><mi>r</mi><mi>u</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\frac{}{(\lambda x.M)y \equiv M[x \mapsto y]} \beta rule</annotation></semantics></math></p>
<p>这条规则告诉我们如何使用一个函数，正向使用这个规则叫做
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>-规约。</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow></mrow><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>f</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≡</mo><mi>f</mi></mrow></mfrac><mi>η</mi><mi>r</mi><mi>u</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\frac{}{(\lambda x.f x) \equiv f} \eta rule</annotation></semantics></math></p>
<p>正向使用这个规则叫做
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>-展开，反向使用则叫
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>-规约。</p>
<p>这个规则看起来没什么必要，但是它其实向我们展示了函数的外延性：因为
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
和
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>f</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\lambda x.f x</annotation></semantics></math>
无论应用上什么参数都是相同的，因此这两个函数也是等价的。</p>
<p>当一个项没法继续使用
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>e</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">beta</annotation></semantics></math>-规约，我们就称这个项是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>-范式。</p>
<p>当一个项没法使用上述任意一条规则，且被完全应用（也就是每个抽象都有一个对应的应用）我们就称这个项是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mi>η</mi></mrow><annotation encoding="application/x-tex">\beta \eta</annotation></semantics></math>-既约的,
简称既约的 (normalized)。</p>
<p>这时我们就会发现无类型
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算的第一个毒点：不是所有的项都能化成
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
范式，或者说
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算并不是停机的。比如我们考虑以下的项：</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>x</mi><mo>↦</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>x</mi><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
         &amp; (\lambda x.x x) (\lambda x.x x) \\
        =&amp; (x x) [x \mapsto \lambda x.x x] \\
        =&amp; (\lambda x.x x) (\lambda x.x x) \\
    \end{aligned}</annotation></semantics></math></p>
<p>我们发现无论如何这个函数都没法被完全规约，它最后总会回到最开始的形式。</p>
<h3 id="邱奇编码">邱奇编码</h3>
<p>邱奇编码使得
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算具有了更多实用意义。通过邱奇编码，我们能将很多东西，比如自然数、布尔值、有序对等等，映射到一个
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
中的项。</p>
<p>如邱奇数能让我们用
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算编码自然数。邱奇编码将自然数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>，表示为任意函数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
映射到它自身的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
重函数复合的一个函数，换言之
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
是一个接受一个函数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
和一个参数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
的函数，返回的是把
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
应用到
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
上
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
次的结果。直观理解一下：
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mn>0</mn><mspace width="0.222em"></mspace><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>x</mi></mtd><mtd columnalign="right" style="text-align: right"><mo>=</mo><mi>λ</mi><mi>f</mi><mi>.</mi><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mn>1</mn><mspace width="0.222em"></mspace><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi></mtd><mtd columnalign="right" style="text-align: right"><mo>=</mo><mi>λ</mi><mi>f</mi><mi>.</mi><mi>λ</mi><mi>x</mi><mi>.</mi><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mn>2</mn><mspace width="0.222em"></mspace><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>f</mi><mspace width="0.222em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="right" style="text-align: right"><mo>=</mo><mi>λ</mi><mi>f</mi><mi>.</mi><mi>λ</mi><mi>x</mi><mi>.</mi><mi>f</mi><mspace width="0.222em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mi>⋯</mi></mtd><mtd columnalign="right" style="text-align: right"></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>n</mi><mspace width="0.222em"></mspace><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msup><mi>f</mi><mi>n</mi></msup><mspace width="0.222em"></mspace><mi>x</mi></mtd><mtd columnalign="right" style="text-align: right"><mo>=</mo><mi>λ</mi><mi>f</mi><mi>.</mi><mi>λ</mi><mi>x</mi><mi>.</mi><msup><mi>f</mi><mi>n</mi></msup><mspace width="0.222em"></mspace><mi>x</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
        0\ f\ x &amp;= x &amp;= \lambda f.\lambda x.x \\
        1\ f\ x &amp;= f\ x &amp;= \lambda f.\lambda x.f\ x \\
        2\ f\ x &amp;= f\ (f\ x) &amp;= \lambda f.\lambda x.f\ (f\ x) \\
        &amp;\cdots&amp; \\
        n\ f\ x &amp;= f^n\ x &amp;= \lambda f.\lambda x.f^n\ x
    \end{aligned}</annotation></semantics></math></p>
<p>类似地我们能定义加法：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>l</mi><mi>u</mi><mi>s</mi><mo>:=</mo><mi>λ</mi><mi>m</mi><mi>.</mi><mi>λ</mi><mi>n</mi><mi>.</mi><mi>λ</mi><mi>f</mi><mi>.</mi><mi>λ</mi><mi>x</mi><mi>.</mi><mi>m</mi><mspace width="0.222em"></mspace><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mspace width="0.222em"></mspace><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">plus := λm.λn.λf.λx. m\ f(n\ f\ x)</annotation></semantics></math>，这是我们由定义可以得来的。</p>
<p>类似地我们还可以做很多有趣的东西。但是对类型论这不太重要。有时间可能会回来补。</p>
<p>重要的是，我们不得不开始考虑
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>l</mi><mi>u</mi><mi>s</mi><mspace width="0.222em"></mspace><mi>n</mi><mspace width="0.222em"></mspace><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">plus\ n\ \lambda x.x</annotation></semantics></math>
或者类似东西的意义——它的确是一个合法的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
项，我们也可以用规则去化简它，但是它和意义很混乱——
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
加上一个函数是什么？我们没法解释。这就是无类型
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算的另一个弊端：虽然我们能表示不同“种类”的东西，但是我们没有手段来确保函数或是其它东西按照我们预想的方式使用它——毕竟不论什么含义最终都是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>项，无论多么胡闹的用法都是合法的。这就需要我们用类型来规范函数的行为。</p>
<h2 id="简单类型-lambda-演算">简单类型
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算</h2>
<h3 id="类型论和一个类型论">类型论和一个类型论</h3>
<p>首先</p>
</body>
