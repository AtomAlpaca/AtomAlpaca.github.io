<!DOCTYPE html>
<html lang = "zh_cn">

<head>
	<meta charset = "utf-8"/>
		<meta name = "author" content = "AtomAlpaca">
		<title>类型论学习笔记</title>
	<link rel = "stylesheet" href = "./style.css" type = "text/css"/>
	<link rel="stylesheet"
      href="https://unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/panda-syntax-dark.min.css">
	<script src="https://unpkg.com/@highlightjs/cdn-assets@11.6.0/highlight.min.js"></script>

</head>

<body>
	<header>
				<p>
			<h1>
				类型论学习笔记
			</h1>
		</p>
		<p style = "text-align: center">
						AtomAlpaca
								</p>
				
			</header>
	<script>hljs.highlightAll();</script>
		<h2>
		Table of contents
	</h2>
	<ul>
<li><a href="#前言" id="toc-前言">前言</a></li>
<li><a href="#前置知识" id="toc-前置知识">前置知识</a>
<ul>
<li><a href="#元语言和形式语言"
id="toc-元语言和形式语言">元语言和形式语言</a></li>
<li><a href="#相继演算" id="toc-相继演算">相继演算</a></li>
<li><a href="#柯里化" id="toc-柯里化">柯里化</a></li>
</ul></li>
<li><a href="#简单类型" id="toc-简单类型">简单类型</a>
<ul>
<li><a href="#无类型-lambda-演算" id="toc-无类型-lambda-演算">无类型
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算</a>
<ul>
<li><a href="#alpha-转换"
id="toc-alpha-转换"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-转换</a></li>
<li><a href="#规约和暨约形式"
id="toc-规约和暨约形式">规约和暨约形式</a></li>
<li><a href="#邱奇编码" id="toc-邱奇编码">邱奇编码</a></li>
</ul></li>
<li><a href="#简单类型-lambda-演算"
id="toc-简单类型-lambda-演算">简单类型
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算</a>
<ul>
<li><a href="#类型论和一个类型论"
id="toc-类型论和一个类型论">类型论和一个类型论</a></li>
<li><a href="#定义类型" id="toc-定义类型">定义类型</a></li>
<li><a href="#语境" id="toc-语境">语境</a></li>
<li><a href="#项" id="toc-项">项</a></li>
<li><a href="#alpha-转换-1"
id="toc-alpha-转换-1"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
转换</a></li>
<li><a href="#规约" id="toc-规约">规约</a></li>
</ul></li>
</ul></li>
</ul>
	
	<h1 id="前言">前言</h1>
<p>是个人学习笔记，会有很多自己的理解和想法，可能有不准确甚至错误的地方。如有发现可以来嘲讽笔者！</p>
<p>由于类型论相关的术语翻译混乱或者难以翻译，有些术语会附上英文原文或直接使用英文。</p>
<p>尝试把笔记写成一篇浅显易懂的入门读物，因此可能很多在诸位认为不重要的地方会花很多笔墨详细解释，以帮助新人理解。</p>
<p>主要是一些入门的内容，以后可能会有类型论进阶学习笔记</p>
<h1 id="前置知识">前置知识</h1>
<h2 id="元语言和形式语言">元语言和形式语言</h2>
<p>……</p>
<h2 id="相继演算">相继演算</h2>
<p>相继演算是一种形如
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>P</mi><mi>r</mi><mi>e</mi><mi>m</mi><mi>i</mi><mi>s</mi><msub><mi>e</mi><mn>1</mn></msub><mo>,</mo><mi>P</mi><mi>r</mi><mi>e</mi><mi>m</mi><mi>i</mi><mi>s</mi><msub><mi>e</mi><mn>2</mn></msub><mi>⋯</mi><mi>P</mi><mi>r</mi><mi>e</mi><mi>m</mi><mi>i</mi><mi>s</mi><msub><mi>e</mi><mi>n</mi></msub></mrow><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>c</mi><mi>l</mi><mi>u</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\frac{Premise_1, Premise_2 \cdots Premise_n}{Conclusion}(Name)</annotation></semantics></math>
的记号，其中分子上是若干条条件（Premise），分母上是结论（Conclusion），旁边是这个演算的名字。它代表的含义是，当分子上的所有条件都成立的时候，分母上的结论成立。</p>
<p>这种记号在类型论的研究中被大量使用。</p>
<h2 id="柯里化">柯里化</h2>
<p>……？</p>
<h1 id="简单类型">简单类型</h1>
<h2 id="无类型-lambda-演算">无类型
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算</h2>
<p>为什么会产生类型？</p>
<p>为了回答这个问题，我们现看看没有类型会发生什么。接下来我们会介绍无类型的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算。说它没有类型也不准确，我们也可以看作它所有的东西共用一个类型。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算中一个项（term）定义为
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mo>:=</mo><mi>x</mi><mrow><mo stretchy="true" form="prefix">|</mo><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">|</mo></mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">term := x | t_1t_2 | \lambda x.t</annotation></semantics></math>，这是说一个项要么是一个单独的变量
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>，要么是两个项的拼接
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_1 t_2</annotation></semantics></math>，要么是形如
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\lambda x.t</annotation></semantics></math>
的形式。</p>
<p>拼接两个项被称为应用（application），它是左结合的，也就是说
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mspace width="0.222em"></mspace><msub><mi>t</mi><mn>2</mn></msub><mspace width="0.222em"></mspace><msub><mi>t</mi><mn>3</mn></msub><mi>⋯</mi><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_1\ t_2\ t_3\cdots t_n</annotation></semantics></math>
代表
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>⋯</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mn>1</mn></msub><mspace width="0.222em"></mspace><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>t</mi><mn>3</mn></msub><mi>⋯</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">(\cdots (t_1\ t_2)t_3 \cdots )t_n</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\lambda x.t</annotation></semantics></math>
这种形式被称为抽象（abstrcation）,其中
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
是一个变量，<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
是一个项。抽象和我们中学时期理解的函数很像，比如我们定义一个函数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">f(x) = x^2</annotation></semantics></math>，我们传入一个参数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>
得到的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">f(y) = y^2</annotation></semantics></math>
其实就是把
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math>
中的所有
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
换成了
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>；而
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">(\lambda x.t) y</annotation></semantics></math>，也就是把
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>
应用到这个项上，代表把项
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
中所有
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
都替换成
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>。注意我们一般规定抽象的优先级比应用要高，也就是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\lambda x.t_1t_2</annotation></semantics></math>
说的是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda x.(t_1t_2)</annotation></semantics></math>
而不是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">(\lambda x.t_1)t_2</annotation></semantics></math>。</p>
<p>我们把
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
中的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
全部替换成
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>
的结果写成
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>x</mi><mo>↦</mo><mi>y</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">M[x \mapsto y]</annotation></semantics></math>。</p>
<h3
id="alpha-转换"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-转换</h3>
<p>我们刚刚知道了
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算的基本规则，那么请思考一个问题：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>y</mi><mi>.</mi><mi>λ</mi><mi>x</mi><mi>.</mi><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>x</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">(\lambda y.\lambda x.y)xz</annotation></semantics></math>
该怎么算？最后得到的是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
还是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>？换言之我们第一步应用得到的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">(\lambda x.x)z</annotation></semantics></math>
中的两个
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
是不是同一个
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>？</p>
<p>其实如果我们换一个变量名
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>y</mi><mi>.</mi><mi>λ</mi><mi>t</mi><mi>.</mi><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>x</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">(\lambda y.\lambda t.y)xz</annotation></semantics></math>
就很清晰了。这个项毫无疑问等于
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>，而我们直觉上认为，<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>t</mi><mi>.</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">\lambda t.y</annotation></semantics></math>
和
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">\lambda x.y</annotation></semantics></math>
是等价的东西，就像
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>sin</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">f(x) = \sin x</annotation></semantics></math>
和
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>sin</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f(y) = \sin y</annotation></semantics></math>
没什么区别一样。事实上在
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算中也是这样规定的。我们接下来形式化地描述一下这种”重命名“的过程。</p>
<p>在一个项
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
中，只要不是在
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\lambda x.</annotation></semantics></math>
的位置使用了一个变量
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>，我们就称这个变量
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
在项
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
中出现（occurence）了。对于一个项
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">\lambda x.M</annotation></semantics></math>，如果
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
这个项中出现了
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>，那么这个项中的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
就是一个绑定变量（bounded variable），否则是一个自由变量（bounded
variable）。我们之前说的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>x</mi><mo>↦</mo><mi>y</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">t[x \mapsto y]</annotation></semantics></math>
严格定义是将
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
中所有自由的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
换成
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>。</p>
<p>同时，我们认为将
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">\lambda x.M</annotation></semantics></math>
中的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
和
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
共同换成一个
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
中自由的变量，变换后的项和原来是等价的。这就是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-转换（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-conversion）。显然地，我们可以把一个项的所有变量都转化为两两不同的变量，这样就不会出现我们上面草歧义。</p>
<p>而之所以我们出现了上面的歧义，是因为我们采用了字符串来代指数学对象，因此我们即使用着同样的名字
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>，两个
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
想表达的意思却是不一样的，就会造成一些混淆。</p>
<h3 id="规约和暨约形式">规约和暨约形式</h3>
<p>归约 (reduction) 主要描述了一个项怎么化简,
或者说计算。而暨约形式（normal
form）则是经过化简得到的所谓“最简形式”。在基础的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算中主要有两条规则：</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow></mrow><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>M</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>y</mi><mo>≡</mo><mi>M</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>x</mi><mo>↦</mo><mi>y</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow></mfrac><mi>β</mi><mi>r</mi><mi>u</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\frac{}{(\lambda x.M)y \equiv M[x \mapsto y]} \beta rule</annotation></semantics></math></p>
<p>这条规则告诉我们如何使用一个函数，正向使用这个规则叫做
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>-规约。</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow></mrow><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>f</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≡</mo><mi>f</mi></mrow></mfrac><mi>η</mi><mi>r</mi><mi>u</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\frac{}{(\lambda x.f x) \equiv f} \eta rule</annotation></semantics></math></p>
<p>正向使用这个规则叫做
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>-展开，反向使用则叫
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>-规约。</p>
<p>这个规则看起来没什么必要，但是它其实向我们展示了函数的外延性：因为
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
和
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>f</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\lambda x.f x</annotation></semantics></math>
无论应用上什么参数都是相同的，因此这两个函数也是等价的。</p>
<p>当一个项没法继续使用
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>e</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">beta</annotation></semantics></math>-规约，我们就称这个项是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>-范式。</p>
<p>当一个项没法使用上述任意一条规则，且被完全应用（也就是每个抽象都有一个对应的应用）我们就称这个项是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mi>η</mi></mrow><annotation encoding="application/x-tex">\beta \eta</annotation></semantics></math>-既约的,
简称既约的 (normalized)。</p>
<p>这时我们就会发现无类型
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算的第一个毒点：不是所有的项都能化成
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
范式，或者说
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算并不是停机的。比如我们考虑以下的项：</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>x</mi><mo>↦</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>x</mi><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
         &amp; (\lambda x.x x) (\lambda x.x x) \\
        =&amp; (x x) [x \mapsto \lambda x.x x] \\
        =&amp; (\lambda x.x x) (\lambda x.x x) \\
    \end{aligned}</annotation></semantics></math></p>
<p>我们发现无论如何这个函数都没法被完全规约，它最后总会回到最开始的形式。</p>
<h3 id="邱奇编码">邱奇编码</h3>
<p>邱奇编码使得
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算具有了更多实用意义。通过邱奇编码，我们能将很多东西，比如自然数、布尔值、有序对等等，映射到一个
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
中的项。</p>
<p>如邱奇数能让我们用
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算编码自然数。邱奇编码将自然数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>，表示为任意函数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
映射到它自身的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
重函数复合的一个函数，换言之
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
是一个接受一个函数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
和一个参数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
的函数，返回的是把
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
应用到
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
上
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
次的结果。直观理解一下：
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mn>0</mn><mspace width="0.222em"></mspace><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>x</mi></mtd><mtd columnalign="right" style="text-align: right"><mo>=</mo><mi>λ</mi><mi>f</mi><mi>.</mi><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mn>1</mn><mspace width="0.222em"></mspace><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi></mtd><mtd columnalign="right" style="text-align: right"><mo>=</mo><mi>λ</mi><mi>f</mi><mi>.</mi><mi>λ</mi><mi>x</mi><mi>.</mi><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mn>2</mn><mspace width="0.222em"></mspace><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>f</mi><mspace width="0.222em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="right" style="text-align: right"><mo>=</mo><mi>λ</mi><mi>f</mi><mi>.</mi><mi>λ</mi><mi>x</mi><mi>.</mi><mi>f</mi><mspace width="0.222em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mi>⋯</mi></mtd><mtd columnalign="right" style="text-align: right"></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>n</mi><mspace width="0.222em"></mspace><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msup><mi>f</mi><mi>n</mi></msup><mspace width="0.222em"></mspace><mi>x</mi></mtd><mtd columnalign="right" style="text-align: right"><mo>=</mo><mi>λ</mi><mi>f</mi><mi>.</mi><mi>λ</mi><mi>x</mi><mi>.</mi><msup><mi>f</mi><mi>n</mi></msup><mspace width="0.222em"></mspace><mi>x</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
        0\ f\ x &amp;= x &amp;= \lambda f.\lambda x.x \\
        1\ f\ x &amp;= f\ x &amp;= \lambda f.\lambda x.f\ x \\
        2\ f\ x &amp;= f\ (f\ x) &amp;= \lambda f.\lambda x.f\ (f\ x) \\
        &amp;\cdots&amp; \\
        n\ f\ x &amp;= f^n\ x &amp;= \lambda f.\lambda x.f^n\ x
    \end{aligned}</annotation></semantics></math></p>
<p>类似地我们能定义加法：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>l</mi><mi>u</mi><mi>s</mi><mo>:=</mo><mi>λ</mi><mi>m</mi><mi>.</mi><mi>λ</mi><mi>n</mi><mi>.</mi><mi>λ</mi><mi>f</mi><mi>.</mi><mi>λ</mi><mi>x</mi><mi>.</mi><mi>m</mi><mspace width="0.222em"></mspace><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mspace width="0.222em"></mspace><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">plus := λm.λn.λf.λx. m\ f(n\ f\ x)</annotation></semantics></math>，这是我们由定义可以得来的。</p>
<p>类似地我们还可以做很多有趣的东西。但是对类型论这不太重要。有时间可能会回来补。</p>
<p>重要的是，我们不得不开始考虑
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>l</mi><mi>u</mi><mi>s</mi><mspace width="0.222em"></mspace><mi>n</mi><mspace width="0.222em"></mspace><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">plus\ n\ \lambda x.x</annotation></semantics></math>
或者类似东西的意义——它的确是一个合法的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
项，我们也可以用规则去化简它，但是它和意义很混乱——
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
加上一个函数是什么？我们没法解释。这就是无类型
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算的另一个弊端：虽然我们能表示不同“种类”的东西，但是我们没有手段来确保函数或是其它东西按照我们预想的方式使用它——毕竟不论什么含义最终都是
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>项，无论多么胡闹的用法都是合法的。这就需要我们用类型来规范函数的行为。</p>
<h2 id="简单类型-lambda-演算">简单类型
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算</h2>
<h3 id="类型论和一个类型论">类型论和一个类型论</h3>
<p>正如集合论根据承认的公理不同有许多分支，类型论也有许多不同的“版本”，如上面提到的无类型
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算，和接下来要讲的简单
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算，这些都可以叫做是“一个类型论”，而“类型论”是研究“这些类型论”的学科。</p>
<h3 id="定义类型">定义类型</h3>
<p>我们不妨用
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝕋</mi><annotation encoding="application/x-tex">\mathbb{T}</annotation></semantics></math>
表示所有简单类型的集合，用
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∈</mo><mi>𝕋</mi></mrow><annotation encoding="application/x-tex">A \in \mathbb{T}</annotation></semantics></math>
来表示
“<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
是一个类型”。对于简单类型
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算，类型是从一个基本集合开始递归定义出来的。首先我们先选定一个基本类型的集合
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝕍</mi><mo>=</mo><mrow><mi>α</mi><mspace width="0.222em"></mspace><mi>β</mi><mi>⋯</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbb{V} = {\alpha \ \beta \cdots}</annotation></semantics></math>，这些都是基本类型（Type
Varibles）：
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>A</mi><mo>∈</mo><mi>𝕍</mi></mrow><mrow><mi>A</mi><mo>∈</mo><mi>𝕋</mi></mrow></mfrac><annotation encoding="application/x-tex">\frac{A \in \mathbb{V}}{A \in \mathbb{T}}</annotation></semantics></math>
在此之上，我们可以递归定义 Arrow Types（我放弃翻译了）
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>∈</mo><mi>𝕋</mi></mrow><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mo>∈</mo><mi>𝕋</mi></mrow></mfrac><annotation encoding="application/x-tex">\frac{A, B \in \mathbb{T}}{A \rightarrow B \in \mathbb{T}}</annotation></semantics></math>
或者抽象一点的形式，我们可以写成
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝕋</mi><mo>=</mo><mi>𝕍</mi><mo stretchy="false" form="prefix">|</mo><mi>𝕋</mi><mo>→</mo><mi>𝕋</mi></mrow><annotation encoding="application/x-tex">\mathbb{T} = \mathbb{V} | \mathbb{T} \rightarrow \mathbb{T}</annotation></semantics></math>。</p>
<h3 id="语境">语境</h3>
<p>类型论中的语境（context）是用来记录在当前，有哪些项存在，它们又拥有哪些类型的，类似列表状物。</p>
<p>语境的定义也是递归的——这和一些函数式语言定义列表的方式相似。首先不包含任何信息的“空列表”是一个语境，我们称其为“空语境”：</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow></mrow><mrow><mi>∅</mi><mspace width="0.222em"></mspace><mi>i</mi><mi>s</mi><mspace width="0.222em"></mspace><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow></mfrac><annotation encoding="application/x-tex">\frac{}{\emptyset\ is\ context}</annotation></semantics></math></p>
<p>在此之上，我们可以追加一个新的陈述，构成一个新的语境：</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>Γ</mi><mspace width="0.222em"></mspace><mi>i</mi><mi>s</mi><mspace width="0.222em"></mspace><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mspace width="0.222em"></mspace><mi>i</mi><mi>s</mi><mspace width="0.222em"></mspace><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow></mfrac><annotation encoding="application/x-tex">\frac{\Gamma\ is\ context}{\Gamma, x:A\ is\ context}</annotation></semantics></math></p>
<p>我们用记号
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x:A</annotation></semantics></math>
来代表
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
是一个合法的，具有
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
类型的项，这被称为是一个陈述（statement）。而对一个语境
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>
中，我们用
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>x</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash x:A</annotation></semantics></math>
来表示“在
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>
这个语境下，<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
是一个合法的项，且具有
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
类型”，这被称为是一个 判断（judgement）。</p>
<h3 id="项">项</h3>
<p>在简单类型
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算中，每个项（Term）都必须有其对应的类型，我们在讨论一个项时不能脱离其类型和所在的语境，这使得我们对项的定义略微复杂一些，其包含四个规则。</p>
<p>首先我们指定一个常量集合
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math>，并给定一个映射
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi><mo>:</mo><mi>𝒞</mi><mo>→</mo><mi>𝕍</mi></mrow><annotation encoding="application/x-tex">type : \mathcal{C} \rightarrow \mathbb{V}</annotation></semantics></math>，为每个常量指定一个类型（映射到
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝕋</mi><annotation encoding="application/x-tex">\mathbb{T}</annotation></semantics></math>
应当也没问题，但我们希望这些常量基础一些），这些是我们指定的基础的项：</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>c</mi><mo>∈</mo><mi>𝒞</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>c</mi><mo>:</mo><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mspace width="0.222em"></mspace><mi>C</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\frac{c \in \mathcal{C}}{\Gamma \vdash c : type(c)}\ Const</annotation></semantics></math></p>
<p>同时我们还希望能从语境中提取信息得到一个合法的项：</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>∈</mo><mi>Γ</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>x</mi><mo>:</mo><mi>A</mi></mrow></mfrac><mspace width="0.222em"></mspace><mi>V</mi><mi>a</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">\frac{x:A \in \Gamma}{\Gamma \vdash x:A}\ Var</annotation></semantics></math></p>
<p>另外我们还希望引入
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算来构建项，这时的
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算要时刻记得考虑类型：</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>M</mi><mo>:</mo><mi>B</mi><mo>,</mo><mi>Γ</mi><mo>⊢</mo><mi>x</mi><mo>:</mo><mi>A</mi></mrow><mrow><mi>λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi><mi>M</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow></mfrac><mi>L</mi><mi>a</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">\frac
        {\Gamma \vdash M : B, \Gamma \vdash x : A}
        {\lambda (x : A).M:A \rightarrow B} Lam</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo>,</mo><mi>Γ</mi><mo>⊢</mo><mi>x</mi><mo>:</mo><mi>A</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi><mo>:</mo><mi>B</mi></mrow></mfrac><mi>A</mi><mi>p</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">\frac
        {\Gamma \vdash f : A \rightarrow B, \Gamma \vdash x : A}
        {\Gamma \vdash f\ x : B} App</annotation></semantics></math></p>
<h3
id="alpha-转换-1"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
转换</h3>
<p>在简单类型
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算中我们仍然可以使用
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
转换。这里我们略去。</p>
<h3 id="规约">规约</h3>
<p>同样我们可以在简单类型
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算中对项进行规约。这些规则在学习了无类型
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
演算之后应该能比较自然地猜出来：</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>,</mo><mi>y</mi><mo>:</mo><mi>A</mi><mo>,</mo><mi>M</mi><mo>:</mo><mi>B</mi></mrow><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mo>:</mo><mi>A</mi><mi>.</mi><mi>M</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.222em"></mspace><mi>y</mi><mo>:</mo><mi>B</mi><mo>≡</mo><mi>M</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>x</mi><mo>↦</mo><mi>y</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>:</mo><mi>B</mi></mrow></mfrac><mi>β</mi><mo>−</mo><mi>r</mi><mi>u</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\frac
    {\Gamma \vdash x : A, y : A, M : B}
    {(\lambda x : A.M)\ y : B \equiv M[x \mapsto y] : B} \beta-rule</annotation></semantics></math>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>f</mi><mi>x</mi><mo>≡</mo><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo></mrow></mfrac><mi>β</mi><mo>−</mo><mi>r</mi><mi>u</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\frac
    {\Gamma \vdash f : A \rightarrow B}
    {\lambda x. f x \equiv f : A \rightarrow} \beta-rule</annotation></semantics></math></p>
<p>加入了类型之后规约有了一些更好的性质，我们来简单讨论一下。</p>
<p>首先我们定义符号
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><msub><mo>→</mo><mi>β</mi></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">M \rightarrow_{\beta} N</annotation></semantics></math>
代表
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
经过一步
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
规约得到了
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>，<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><msub><mo>↠</mo><mi>β</mi></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">M \twoheadrightarrow_{\beta} N</annotation></semantics></math>
代表
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
经过多步
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
规约得到了
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math></p>
</body>
